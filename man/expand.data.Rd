% Generated by roxygen2 (4.1.1): do not edit by hand
% Please edit documentation in R/expand.data.R
\name{expand.data}
\alias{expand.data}
\title{Expand Data}
\usage{
expand.data(comD, arr.dim, keyValue = "value", fillID = NULL,
  fillValue = NA, Rule = NULL, keyID = NULL, gScope = NULL,
  fScope = NULL, vScope = NULL, redID = NULL, redValue = NULL,
  arrayOut = FALSE, aggFun = NULL, maxOut = Inf)
}
\arguments{
\item{comD}{the "compact" data set, supplied as a data.table}

\item{arr.dim}{character vector specifying the names of columns that would specify the dimensions of the output array}

\item{keyValue}{the name of the column whose values, along with those in fillValue, will form the elements of the output array}

\item{fillID}{a list of character vectors, each of which is a subset of scope, and when missing levels of these factor/s are added for existing combinations of \code{setdiff(arr.dim, fillID[[i]])}, should be filled in with the corresponding value of fillValue. Note that the last element of fillID will always contain the full set in arr.dim, because the resulting array cannot be ragged.}

\item{fillValue}{a vector of values that should be used to fill in missing combinations of arr.dim. The class of fillValue should match the class of keyValue.}

\item{Rule}{rule for filling (key or value)}

\item{keyID}{columns in keyID will either define the arr.dim, the elements of the output array, or, for those elements not in either of those, will be aggreated over}

\item{gScope}{character vector indicating columns whose values' combinations define the maximum scope of expansion. For all combinations of variables indicated here, expansion effectively occurs separately. E.g., setting \code{gScope="reg"} would prevent this function from adding combinations of variables between regions (e.g., combinations of spp from 'ai' and strata from 'gmex').}

\item{fScope}{fill scope}

\item{vScope}{value scope}

\item{redID}{a list of the categories to uniquely define redValue; can only include values in arr.dim, but must not include all of them}

\item{redValue}{a list of character vectors whose elements correspond to column names whose levels are redundant with some subset of keyID; e.g., if a keyID is "species", then redValue would include columns like Genus and Family, specified as \code{list(c("Genus","Family"))}, and the corresponding redID would be \code{list(c("species"))}.}

\item{arrayOut}{logical; Defaults to FALSE, in which case the output is a data.table, with number of rows corresponding to the product of the number of unique values in each of arr.dim (in the case where scope=NULL), or the sum of that product for each of the unique combinations of the levels in scope. If TRUE, the output is an array (if scope=NULL), or list of arrays.}

\item{aggFun}{Function used to aggregate among levels of columns specified in keyID, but not present in arr.dim.}

\item{maxOut}{the maximum number of allowable elements in the output array or data.table. In place to prevent early detection of a huge number of combinations that might use up a larger-than-expected amount of memory.
The main purpose of this function is to do something very similar to \code{merge(data, data[,do.call(expand.grid, list(id1, id2))], all=TRUE)}, and then follow that by trimming out of combinations you didn't need due to scoping. I.e., to look for all possible combinations of some variables (id1 id2), and then merge all of those combinations back into your original data set to create NA's but to ensure combinations are available. However, the process of finding all combinations might ideally occur for a subset of the data at a time, such that all combinations are only found among those variables per unique value of some other column. To make things more complicated, different combinations might need to occur for different subsets. Creating many extra combinations and trimming them out, or doing things more directly, is fine when the data set is small enough to manage all of those combinations in memory; however, this can be slow or prohibitive for large data sets. This function seeks to
still testing!!}
}
\description{
Expand data set to include 0's, and reformat to array to save memory
}

